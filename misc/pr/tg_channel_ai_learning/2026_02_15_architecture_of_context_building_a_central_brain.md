**Архитектура контекста: Как превратить репозиторий в «мозг» для LLM-агентов**

Обновлений снова много, Claude Code значительно ускоряет работу, перехожу на постоянную подписку.

Ключевая новость: отдельный репозиторий ai_engineering_handbook начал разрастаться в экосистему - ожидаемое и органичное развитие событий. Данный репозиторий изначально задумывался как мозг/штаб системы, собирающий в себя все ключевые методологические принципы и подходы. Контекст для LLM - "документация-как-код". В ближайшее время надо создавать RAG на базе этого репо.

Для этой экосистемы создана организация на GitHub - soviar-systems (СовИАР - Современные информационно-аналитические решения) https://github.com/soviar-systems. На текущий момент в экосистеме разрабатываются следующие репозитории:
- ai_engineering_handbook - методолгический штаб экосистемы
- mentor_generator - метапромпт, который создает персональных ИИ менторов для изучения новых тем
- research - монорепо для изучения и исследования различных тем, необходимых в эпоху ИИ, с помощью ИИ менторов, созданных mentor_generator
- vadocs - первый в экосистеме Python пакет, созданный для реализации концепции "документация-как-код", пока в стадии PoC.

Репозитории работают не в связке, приходится синхронизировать проверки в ручном режиме, эта проблема будет закрыта пакетами vadocs и планируемым пакетом по гит-валидации. Пакеты должны распространять общие политики валидации и верификации документации и гит-методологии по всем репозиториям экосистемы.

Документация репозиториев публикуется в формате веб-сайтов на гитхабовских серверах - это умышленный уход от личного сервера, так как документация open-source проектов не должна зависеть от личного сервера. На текущий момент опубликована документация для двух репозиториев:
- ai_engineering_handbook - https://soviar-systems.github.io/ai_engineering_handbook/
- vadocs - https://soviar-systems.github.io/vadocs/

Попробую прицепить их к моему домену, чтобы адреса выглядели покрасивее, пока с кондачка не удалось это сделать.

Подробнее по репозиториям.

1. Генератор менторов - переехал в репо организации из личного гитхаба со всей историей. Над ментором ведется активная работа в экспериментальном режиме в ветке develop. Проведены эксперименты с различными архитектурами, стабильного результата пока нет. Получен богатый исследовательский материал, на базе которого уже подготовлена статья "Формат как архитектура: Соотношение шум-сигнал в доставке промпта" ("Format as Architecture: Signal-to-Noise in Prompt Delivery" https://soviar-systems.github.io/ai_engineering_handbook/format-as-architecture-signal-noise-in-prompt-delivery/)

2. ai_engineering_handbook
- более менее наведен порядок в ADR, все записи распределены по трем разделам в adr_index https://soviar-systems.github.io/ai_engineering_handbook/adr-index/: активные, предложенные (читай: RFC), исторические (отвергнутые, замененные)

3. research - создан новый курс по новой профессии AI Code Generation Engineer, уже на основе обновленного генератора менторов https://github.com/soviar-systems/research/tree/main/ai_code_generation_engineer

Если подводить итоги, то выработался следующий метод работы с контекстом:
- перед любой разработкой тщательно проработать план и сохранить его в misc/plan/
- любое архитектурное решение, которое требуется принять/отвергуть, тут же фиксируется в adr/ репозитория, в котором работаешь,
- ADR в качестве фундаментального контекста передаются агенту как при планировании задач, так и в ходе их выполнения для корректировки,
- при обнаружении инсайтов в ходе решения задач все находки либо оформляются либо в ADR, либо уходят в другую документацию,
- при обнаружении масштабных проблем пишется детальный post-mortem, который при необходимости так же отправляется агенту в качестве контекста.

Главный вывод: вся проделанная работа должна тем или иным образом суммаризироваться и оформляться в документацию.

При этом просто сохранять информацию в какие-то файлы не имеет смысла - вы получите свалку из материалов. Требуется поддерживать четкую структуру репозитория, которая фиксируется как отдельное архитектурное решение и подвергается такому же рефакторингу, как программный код.
